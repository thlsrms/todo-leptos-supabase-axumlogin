create table
  public.tasks (
    id bigint generated by default as identity,
    author_id uuid not null,
    title text not null,
    completed boolean not null default false,
    description text null,
    constraint tasks_pkey primary key (id),
    constraint tasks_id_key unique (id),
    constraint tasks_author_id_fkey foreign key (author_id) references auth.users (id) on delete cascade
  ) tablespace pg_default;

alter table public.tasks enable row level security;
create policy "Individuals can create tasks." on public.tasks for
    insert with check (auth.uid() = author_id);
create policy "Individuals can view their own tasks. " on public.tasks for
    select using ((select auth.uid()) = author_id);
create policy "Individuals can update their own tasks." on public.tasks for
    update using ((select auth.uid()) = author_id);
create policy "Individuals can delete their own tasks." on public.tasks for
    delete using ((select auth.uid()) = author_id);

create table
  public.sessions (
    id text not null,
    sb_id uuid not null,
    data character varying null,
    refreshed_at timestamp without time zone null,
    created_at timestamp with time zone null,
    expiry_date timestamp with time zone null,
    constraint sessions_pkey primary key (sb_id, id),
    constraint sessions_app_session_id_key unique (id),
    constraint sessions_id_fkey foreign key (sb_id) references auth.sessions (id) on delete cascade
  ) tablespace pg_default;

alter table public.sessions enable row level security;

create function public.handle_session_created () returns trigger language plpgsql security definer
set
  search_path = '' as $$
begin
  insert into public.sessions (id, sb_id, created_at, expiry_date)
  values (new.id, new.id, new.created_at, new.not_after);
  return new;
end;
$$;

create trigger on_auth_session_created
after insert on auth.sessions for each row
execute procedure public.handle_session_created ();

